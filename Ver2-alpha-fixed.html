<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>メモアプリ風UI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="text/javascript" id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script>
        // MathJaxの基本設定
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']], // インライン数式のデリミタ
                displayMath: [['$$', '$$'], ['\\[', '\\]']] // ディスプレイ数式のデリミタ
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <style>
        /* Google Fonts - Inter */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f0f0; /* 全体の背景色 */
        }
        /* カスタムスクロールバーのスタイル */
        .scrollable-content::-webkit-scrollbar {
            width: 8px;
        }
        .scrollable-content::-webkit-scrollbar-track {
            background: #e0e0e0;
            border-radius: 10px;
        }
        .scrollable-content::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        .scrollable-content::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        /* モーダルの表示/非表示アニメーション */
        .modal-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .modal-overlay {
            transition: opacity 0.3s ease-in-out;
        }
        .modal-content {
            transform: translateY(20px);
            opacity: 0;
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
        }
        .modal-overlay.flex .modal-content {
            transform: translateY(0);
            opacity: 1;
        }
        /* フィルター選択肢のスタイル */
        .filter-options {
            position: absolute;
            top: 100%; /* ボタンの真下に表示 */
            left: 0;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            z-index: 10;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.2s ease-out, transform 0.2s ease-out;
            pointer-events: none;
            min-width: 150px; /* 最小幅を設定 */
            padding: 8px 0; /* 上下のパディング */
        }
        .filter-options.active {
            opacity: 1;
            transform: translateY(0);
            pointer-events: all;
        }
        .filter-option-item {
            padding: 8px 16px;
            cursor: pointer;
            color: #4a5568; /* gray-700 */
            font-size: 0.9rem;
            transition: background-color 0.15s ease-in-out, color 0.15s ease-in-out;
        }
        .filter-option-item:hover {
            background-color: #f0f0f0; /* gray-100 */
            color: #2d3748; /* gray-800 */
        }
        .filter-option-item.selected {
            background-color: #e2e8f0; /* blue-100 */
            color: #2b6cb0; /* blue-700 */
            font-weight: 600;
        }
        /* 検索入力フィールドとクリアボタンのコンテナ */
        .search-input-container {
            position: relative;
            flex-grow: 1; /* 検索入力フィールドが利用可能なスペースを占めるように */
        }
        /* クリアボタンのスタイル */
        #clearSearchButton {
            position: absolute;
            right: 8px; /* 検索入力フィールドの右端から少し内側 */
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #9ca3af; /* gray-400 */
            cursor: pointer;
            padding: 4px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0; /* デフォルトで非表示 */
            transition: opacity 0.2s ease-in-out, background-color 0.2s ease-in-out;
        }
        #clearSearchButton:hover {
            background-color: #e5e7eb; /* gray-200 */
            color: #6b7280; /* gray-500 */
        }
        /* 検索入力フィールドにテキストがあるときにクリアボタンを表示 */
        #searchNotesInput:not(:placeholder-shown) + #clearSearchButton,
        #searchNotesInput:focus + #clearSearchButton {
            opacity: 1;
        }

        /* ノートグリッドのレイアウト */
        .notes-grid-layout {
            grid-template-columns: repeat(1, minmax(0, 1fr)); /* モバイルでは1列 */
        }
        @media (min-width: 768px) { /* md */
            .notes-grid-layout {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }
        }
        @media (min-width: 1024px) { /* lg */
            .notes-grid-layout {
                grid-template-columns: repeat(3, minmax(0, 1fr));
            }
        }

        /* ノートリストのレイアウト */
        .notes-list-layout {
            grid-template-columns: 1fr; /* 常に1列 */
            gap: 16px; /* gap-4と同じ */
        }
        .notes-list-layout .note-card {
            width: 100%; /* 横幅いっぱいに */
            max-width: none; /* 最大幅の制限を解除 */
            height: auto; /* 高さを自動調整 */
        }

        /* 各メディア入力アイテムのスタイル */
        .media-input-item {
            background-color: #f8f8f8;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 12px;
            position: relative;
            padding-right: 96px; /* ボタンの幅 + バッファでコンテンツの重なりを防ぐ */
        }
        .media-input-item .media-input-label {
            font-weight: 500;
            font-size: 0.875rem; /* sm text size */
            color: #4a5568;
            margin-bottom: 6px;
        }
        .media-input-item input[type="url"],
        .media-input-item textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #cbd5e0;
            border-radius: 6px;
            background-color: white;
            font-size: 0.9rem;
            color: #2d3748;
            /* 追加: 長いURLやテキストの折り返しを強制 */
            word-break: break-all;
        }
        .media-input-item input[type="url"]:focus,
        .media-input-item textarea:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(66, 153, 225, 0.5); /* blue-500 focus ring */
        }
        /* ノートカード内のコンテンツ表示用スタイル */
        .note-card .note-body p,
        .note-card .note-body pre,
        .note-card .note-body img,
        .note-card .note-body audio,
        .note-card .note-body video,
        .note-card .note-body .markdown-content { /* markdown-contentにもスタイル適用 */
            margin-top: 8px;
            margin-bottom: 8px;
        }
        .note-card .note-body img,
        .note-card .note-body video {
            max-width: 100%; /* Ensure images/videos fit within card */
        }
        .note-card .note-body pre {
            white-space: pre-wrap; /* Preserve whitespace and wrap long lines */
            word-break: break-word; /* Break long words */
        }
        /* Markdownコンテンツ内の要素のスタイル調整 */
        .markdown-content h1, .markdown-content h2, .markdown-content h3,
        .markdown-content h4, .markdown-content h5, .markdown-content h6 {
            font-weight: bold;
            margin-top: 1em;
            margin-bottom: 0.5em;
        }
        .markdown-content h1 { font-size: 1.5em; }
        .markdown-content h2 { font-size: 1.3em; }
        .markdown-content h3 { font-size: 1.1em; }
        .markdown-content ul, .markdown-content ol {
            list-style-position: inside;
            margin-left: 1.5em;
        }
        .markdown-content li {
            margin-bottom: 0.25em;
        }
        .markdown-content a {
            color: #2b6cb0; /* blue-700 */
            text-decoration: underline;
        }
        .markdown-content pre, .markdown-content code {
            background-color: #e2e8f0; /* gray-200 */
            padding: 0.2em 0.4em;
            border-radius: 4px;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
        }
        .markdown-content pre {
            display: block;
            padding: 1em;
            overflow-x: auto;
        }
        /* 新しいメディア追加ボタンのスタイル */
        .media-add-button {
            @apply flex-1 py-2 rounded-md border border-gray-300 transition-colors duration-200 flex items-center justify-center space-x-2 text-sm font-medium;
            @apply bg-gray-50 text-gray-700 hover:bg-gray-100;
        }
        .media-add-button svg {
            @apply w-5 h-5;
        }
        /* メディア操作ボタン群のスタイル */
        .media-action-buttons {
            @apply flex space-x-1; /* ボタン間のスペース */
            position: absolute;
            top: 8px;
            right: 8px;
            z-index: 10; /* 他の要素の上に表示 */
        }
        .media-action-buttons button {
            @apply w-6 h-6 p-1 rounded-full flex items-center justify-center transition-colors duration-200;
        }
        .media-action-buttons .move-up-media-button,
        .media-action-buttons .move-down-media-button {
            @apply hover:bg-blue-100 text-blue-600 hover:text-blue-700; /* 青系のホバー効果 */
        }
        .media-action-buttons .remove-media-button {
            @apply hover:bg-red-100 text-gray-500 hover:text-gray-700; /* デフォルトの灰色のアイコン色 */
        }
        .media-action-buttons svg {
            @apply w-4 h-4; /* アイコンサイズを少し小さく */
        }

        /* タグチップのスタイル */
        .tag-chip {
            @apply inline-flex items-center bg-blue-100 text-blue-800 text-xs font-medium px-2.5 py-0.5 rounded-full mr-2 mb-2;
        }
        .tag-chip-remove {
            @apply inline-flex items-center p-1 ml-2 text-blue-700 bg-transparent rounded-full hover:bg-blue-200 hover:text-blue-900;
        }
        .tag-display-container {
            @apply flex flex-wrap gap-2 mt-2 mb-4; /* Tags will appear here */
        }
    </style>
</head>
<body class="flex flex-col min-h-screen items-center justify-center p-4 sm:p-6 md:p-8 bg-gray-100">
    <div class="w-full max-w-4xl bg-white rounded-xl shadow-lg flex flex-col h-[90vh] overflow-hidden">
        <header class="flex items-center justify-between p-4 sm:p-5 border-b border-gray-200 bg-white shadow-sm flex-shrink-0">
            <div class="flex items-center space-x-2 sm:space-x-4 w-full md:w-auto relative">
                <div id="filterButton" class="filter-icon w-8 h-8 sm:w-10 sm:h-10 p-2 rounded-full bg-gray-200 flex items-center justify-center cursor-pointer hover:bg-gray-300 transition-colors duration-200">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-filter text-gray-600">
                        <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/>
                    </svg>
                </div>
                <div id="filterOptions" class="filter-options hidden">
                    <div class="filter-option-item selected" data-filter="both">両方</div>
                    <div class="filter-option-item" data-filter="title">タイトルのみ</div>
                    <div class="filter-option-item" data-filter="content">内容のみ</div>
                </div>
                <div class="search-input-container">
                    <input type="text" id="searchNotesInput" placeholder="メモを検索..." class="w-full p-2 sm:p-2.5 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-700 pr-10">
                    <button id="clearSearchButton" class="w-6 h-6">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x text-gray-400">
                            <path d="M18 6 6 18"/><path d="m6 6 12 12"/>
                        </svg>
                    </button>
                </div>
            </div>
            <div class="flex items-center space-x-2 sm:space-x-3">
                <button id="addNoteButton" class="group relative flex items-center justify-center
                                                   bg-green-500 text-white rounded-lg shadow-md
                                                   hover:bg-green-600 transition-all duration-300 ease-in-out
                                                   w-10 h-10 p-2.5 overflow-hidden
                                                   hover:w-auto hover:px-4">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-plus flex-shrink-0">
                        <path d="M12 5v14"/><path d="M5 12h14"/>
                    </svg>
                    <span class="text-white text-sm font-medium
                                 absolute left-1/2 -translate-x-1/2 opacity-0
                                 group-hover:opacity-100 group-hover:static group-hover:translate-x-0
                                 ml-2 whitespace-nowrap transition-all duration-300 ease-in-out">
                        メモを追加
                    </span>
                </button>
                <button id="toggleLayoutButton" class="header-button bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-3 sm:py-2.5 sm:px-4 rounded-lg shadow-md transition-all duration-200 transform hover:scale-105">
                    <svg id="gridIcon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-white">
                        <rect x="3" y="3" width="7" height="7" rx="1" ry="1"/>
                        <rect x="14" y="3" width="7" height="7" rx="1" ry="1"/>
                        <rect x="3" y="14" width="7" height="7" rx="1" ry="1"/>
                        <rect x="14" y="14" width="7" height="7" rx="1" ry="1"/>
                    </svg>
                    <svg id="listIcon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-white hidden">
                        <rect x="3" y="3" width="18" height="4" rx="1" ry="1"/>
                        <rect x="3" y="10" width="18" height="4" rx="1" ry="1"/>
                        <rect x="3" y="17" width="18" height="4" rx="1" ry="1"/>
                    </svg>
                </button>
            </div>
        </header>

        <main id="notesContainer" class="flex-grow p-4 sm:p-6 overflow-y-auto scrollable-content">
            <div class="grid gap-4 notes-grid-layout" id="notesGrid">
                <!-- Notes will be dynamically loaded here -->
            </div>
        </main>

        <!-- メモ追加/編集モーダル -->
        <div id="noteModal" class="modal-overlay fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 hidden">
            <div class="modal-content bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
                <h3 id="modalTitle" class="text-xl font-semibold mb-4 text-gray-800">メモを追加</h3>
                <input type="text" id="noteTitleInput" placeholder="タイトル" class="w-full p-2 border border-gray-300 rounded-md mb-3 focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-700">
                <textarea id="noteContentInput" placeholder="メモ内容" rows="6" class="w-full p-2 border border-gray-300 rounded-md mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-700"></textarea>

                <!-- タグ入力コンテナ -->
                <div class="mb-4">
                    <label for="tagInput" class="block text-sm font-medium text-gray-700 mb-1">タグ (カンマまたはEnterで追加)</label>
                    <input type="text" id="tagInput" placeholder="例: 仕事, アイデア, 重要" class="w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 text-gray-700">
                    <div id="tagsDisplayArea" class="tag-display-container">
                        <!-- タグチップがここに動的に追加されます -->
                    </div>
                </div>

                <!-- メディア入力コンテナ - スクロール可能に設定 -->
                <div id="mediaInputsContainer" class="space-y-3 mb-4 max-h-60 overflow-y-auto pr-2"></div>

                <!-- メディア追加ボタン群を囲むラッパー -->
                <div class="mb-4 flex flex-col items-center">
                    <p class="text-gray-700 text-sm font-medium mb-2">メディアを追加</p>
                    <div class="flex flex-wrap gap-2 justify-center w-full max-w-xs">
                        <button id="addMediaImageButton" class="media-add-button text-blue-500">
                            <i class="fas fa-image"></i>
                            <span>画像</span>
                        </button>
                        <button id="addMediaAudioButton" class="media-add-button text-purple-500">
                            <i class="fas fa-volume-up"></i>
                            <span>音声</span>
                        </button>
                        <button id="addMediaVideoButton" class="media-add-button text-green-500">
                            <i class="fas fa-video"></i>
                            <span>映像</span>
                        </button>
                        <button id="addMediaMarkdownButton" class="media-add-button text-orange-500">
                            <i class="fas fa-file-alt"></i>
                            <span>マークダウン</span>
                        </button>
                    </div>
                </div>

                <div class="flex justify-end space-x-3">
                    <button id="cancelNoteButton" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 transition-colors duration-200">キャンセル</button>
                    <button id="saveNoteButton" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors duration-200">保存</button>
                </div>
            </div>
        </div>

        <!-- 削除確認モーダル -->
        <div id="deleteConfirmModal" class="modal-overlay fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 hidden">
            <div class="modal-content bg-white p-6 rounded-lg shadow-xl w-full max-w-sm text-center">
                <h3 class="text-xl font-semibold mb-4 text-gray-800">メモを削除</h3>
                <p class="text-gray-700 mb-6">本当にこのメモを削除しますか？</p>
                <div class="flex justify-center space-x-4">
                    <button id="cancelDeleteButton" class="px-5 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 transition-colors duration-200">キャンセル</button>
                    <button id="confirmDeleteButton" class="px-5 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors duration-200">削除</button>
                </div>
            </div>
        </div>

        <!-- メモ詳細モーダル -->
        <div id="noteDetailModal" class="modal-overlay fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 hidden">
            <div class="modal-content bg-white p-6 rounded-lg shadow-xl w-full max-w-2xl h-3/4 flex flex-col">
                <div class="flex justify-between items-center mb-4 border-b pb-3">
                    <h3 id="detailModalTitle" class="text-2xl font-semibold text-gray-800"></h3>
                    <button id="closeDetailModalButton" class="text-gray-500 hover:text-gray-700">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x">
                            <path d="M18 6 6 18"/><path d="m6 6 12 12"/>
                        </svg>
                    </button>
                </div>
                <!-- タグ表示エリア -->
                <div id="detailModalTags" class="tag-display-container mt-2">
                    <!-- 詳細表示のタグチップがここに動的に追加されます -->
                </div>
                <div id="detailModalContent" class="note-body overflow-y-auto flex-grow pb-4 scrollable-content">
                    <!-- メモの本文とメディアがここに表示されます -->
                </div>
                <div class="flex justify-end mt-4 pt-3 border-t">
                    <button id="closeDetailModalButtonFooter" class="px-5 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 transition-colors duration-200">閉じる</button>
                </div>
            </div>
        </div>
    </div>

    <!-- marked.jsを読み込み (Markdownレンダリング用) -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <script>
        // DOM要素の取得
        const addNoteButton = document.getElementById('addNoteButton');
        const noteModal = document.getElementById('noteModal');
        const modalTitle = document.getElementById('modalTitle');
        const noteTitleInput = document.getElementById('noteTitleInput');
        const noteContentInput = document.getElementById('noteContentInput'); // メインのテキストエリア
        const tagInput = document.getElementById('tagInput'); // タグ入力フィールド
        const tagsDisplayArea = document.getElementById('tagsDisplayArea'); // タグチップ表示エリア
        const mediaInputsContainer = document.getElementById('mediaInputsContainer'); // メディア入力のコンテナ
        
        // メディア追加ボタンのID
        const addMediaImageButton = document.getElementById('addMediaImageButton');
        const addMediaAudioButton = document.getElementById('addMediaAudioButton');
        const addMediaVideoButton = document.getElementById('addMediaVideoButton');
        const addMediaMarkdownButton = document.getElementById('addMediaMarkdownButton');

        const saveNoteButton = document.getElementById('saveNoteButton');
        const cancelNoteButton = document.getElementById('cancelNoteButton');
        const notesGrid = document.getElementById('notesGrid');
        const deleteConfirmModal = document.getElementById('deleteConfirmModal');
        const cancelDeleteButton = document.getElementById('cancelDeleteButton');
        const confirmDeleteButton = document.getElementById('confirmDeleteButton');
        const searchNotesInput = document.getElementById('searchNotesInput');
        const filterButton = document.getElementById('filterButton');
        const filterOptions = document.getElementById('filterOptions');
        const filterOptionItems = document.querySelectorAll('.filter-option-item');
        const clearSearchButton = document.getElementById('clearSearchButton');
        const toggleLayoutButton = document.getElementById('toggleLayoutButton');
        const gridIcon = document.getElementById('gridIcon');
        const listIcon = document.getElementById('listIcon');

        // メモ詳細モーダルのDOM要素
        const noteDetailModal = document.getElementById('noteDetailModal');
        const detailModalTitle = document.getElementById('detailModalTitle');
        const detailModalContent = document.getElementById('detailModalContent');
        const detailModalTags = document.getElementById('detailModalTags'); // タグ表示エリア
        const closeDetailModalButton = document.getElementById('closeDetailModalButton');
        const closeDetailModalButtonFooter = document.getElementById('closeDetailModalButtonFooter');

        let isEditing = false; // 編集モードかどうかのフラグ
        let editingNoteCard = null; // 編集中のメモカードを保持
        let currentFilter = 'both'; // 現在のフィルター設定 ('both', 'title', 'content')
        let isGridLayout = true; // 現在のレイアウト設定 (true: グリッド, false: リスト)
        // Global variable to hold the ID of the media selected for card display in the modal
        let selectedMediaForCardDisplayId = null;
        let currentTags = []; // 現在編集中のメモのタグを保持する配列

        /**
         * Function to display a temporary message
         * @param {string} message - The message to display.
         * @param {'info'|'success'|'error'} type - The type of message for styling.
         */
        const displayMessage = (message, type = 'info') => {
            const messageBox = document.createElement('div');
            messageBox.className = `fixed top-4 right-4 px-5 py-3 rounded-lg shadow-lg text-white z-50 transition-all duration-300 transform translate-x-full opacity-0`;

            if (type === 'error') {
                messageBox.classList.add('bg-red-600');
            } else if (type === 'success') {
                messageBox.classList.add('bg-green-600');
            } else { // info
                messageBox.classList.add('bg-blue-600');
            }

            messageBox.textContent = message;
            document.body.appendChild(messageBox);

            // Fade in
            setTimeout(() => {
                messageBox.classList.remove('translate-x-full', 'opacity-0');
                messageBox.classList.add('translate-x-0', 'opacity-100');
            }, 100);

            // Fade out and remove after 3 seconds
            setTimeout(() => {
                messageBox.classList.remove('translate-x-0', 'opacity-100');
                messageBox.classList.add('translate-x-full', 'opacity-0');
                messageBox.addEventListener('transitionend', () => messageBox.remove());
            }, 3000);
        };


        // モーダルを開く関数
        const openNoteModal = (title, currentTitle = '') => {
            modalTitle.textContent = title;
            noteTitleInput.value = currentTitle;
            // noteContentInput と mediaInputsContainer のクリアは、
            // addNoteButton と edit-note-button のリスナーで適切に処理されるため、ここでは行わない

            // タグ関連の初期化
            currentTags = [];
            tagsDisplayArea.innerHTML = '';
            tagInput.value = '';

            noteModal.classList.remove('hidden');
            // アニメーションのために少し遅延させてflexクラスを追加
            setTimeout(() => {
                noteModal.classList.add('flex');
            }, 10);
        };

        // モーダルを閉じる関数
        const closeNoteModal = () => {
            noteModal.classList.remove('flex');
            noteModal.classList.add('hidden');
            noteTitleInput.value = '';
            noteContentInput.value = ''; // メインのテキストエリアをクリア
            mediaInputsContainer.innerHTML = ''; // メディア入力コンテナをクリア
            selectedMediaForCardDisplayId = null; // リセット
            isEditing = false;
            editingNoteCard = null;
            // タグ関連もリセット
            currentTags = [];
            tagsDisplayArea.innerHTML = '';
            tagInput.value = '';
        };

        // 削除確認モーダルを開く関数
        const openDeleteConfirmModal = () => {
            deleteConfirmModal.classList.remove('hidden');
            setTimeout(() => {
                deleteConfirmModal.classList.add('flex');
            }, 10);
        };

        // 削除確認モーダルを閉じる関数
        const closeDeleteConfirmModal = () => {
            deleteConfirmModal.classList.remove('flex');
            deleteConfirmModal.classList.add('hidden');
            editingNoteCard = null;
        };

        /**
         * メモ詳細モーダルを開く関数
         * @param {Object} noteData - 表示するメモのデータ (title, contentParts, tagsを含む)
         */
        const openNoteDetailModal = (noteData) => {
            detailModalTitle.textContent = noteData.title;
            // タグの表示
            detailModalTags.innerHTML = ''; // クリア
            if (noteData.tags && noteData.tags.length > 0) {
                noteData.tags.forEach(tag => {
                    const tagChip = document.createElement('span');
                    tagChip.classList.add('tag-chip');
                    tagChip.textContent = tag;
                    detailModalTags.appendChild(tagChip);
                });
            } else {
                const noTags = document.createElement('span');
                noTags.classList.add('text-sm', 'text-gray-500');
                noTags.textContent = 'タグなし';
                detailModalTags.appendChild(noTags);
            }

            // detailModalContent にコンテンツをレンダリング (displayMediaIdをnullで渡し、全て表示)
            renderNoteContent(detailModalContent, noteData.contentParts, null);
            noteDetailModal.classList.remove('hidden');
            setTimeout(() => {
                noteDetailModal.classList.add('flex');
            }, 10);
        };

        /**
         * メモ詳細モーダルを閉じる関数
         */
        const closeNoteDetailModal = () => {
            noteDetailModal.classList.remove('flex');
            noteDetailModal.classList.add('hidden');
            detailModalTitle.textContent = '';
            detailModalContent.innerHTML = ''; // コンテンツをクリア
            detailModalTags.innerHTML = ''; // タグをクリア
        };


        /**
         * メディア入力要素をモーダルに追加する関数
         * @param {string} type - メディアのタイプ ('image', 'audio', 'video', 'markdown')
         * @param {string} value - 入力フィールドの初期値 (URLまたはマークダウンテキスト)
         * @param {string|null} [existingMediaId=null] - 既存のメディアのID (編集時)
         */
        const addMediaInput = (type, value = '', existingMediaId = null) => {
            // 新規追加時はユニークなIDを生成、既存メディアの編集時はそのIDを使用
            const mediaId = existingMediaId || `media-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
            const mediaItemDiv = document.createElement('div');
            mediaItemDiv.classList.add('media-input-item', 'relative', 'p-3', 'rounded-lg', 'border', 'border-gray-200', 'bg-gray-50');
            mediaItemDiv.dataset.type = type;
            mediaItemDiv.dataset.mediaId = mediaId;

            let inputElement;
            let labelText;
            let placeholderText;

            if (type === 'markdown') {
                labelText = 'マークダウン内容';
                inputElement = document.createElement('textarea');
                inputElement.rows = 5;
                placeholderText = '例: # 見出し\n\n- リストアイテム\n- `コード`\n\n$E=mc^2$'; // Markdownの例
            } else {
                labelText = type === 'image' ? '画像URL' : (type === 'audio' ? '音声URL' : '映像URL');
                inputElement = document.createElement('input');
                inputElement.type = 'url';
                placeholderText = '例: https://example.com/media.jpg'; // URLの例
            }

            inputElement.classList.add('w-full', 'p-2', 'border', 'border-gray-300', 'rounded-md', 'focus:outline-none', 'focus:ring-2', 'focus:ring-blue-500', 'text-gray-700');
            inputElement.placeholder = placeholderText;
            inputElement.value = value;
            inputElement.dataset.mediaInput = type;
            inputElement.dataset.mediaItemId = mediaId; // input要素にもIDを付与

            // NOTE: The order of buttons is important for styling.
            // Move up/down buttons are to the left of the remove button.
            mediaItemDiv.innerHTML = `
                <label class="media-input-label block text-sm font-medium text-gray-700 mb-1">${labelText}</label>
                <div class="media-action-buttons">
                    <button type="button" class="move-up-media-button">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-up"><path d="m5 12 7-7 7 7"/><path d="M12 19V5"/></svg>
                    </button>
                    <button type="button" class="move-down-media-button">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-down"><path d="m19 12-7 7-7-7"/><path d="M12 5v14"/></svg>
                    </button>
                    <button type="button" class="remove-media-button">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
                    </button>
                </div>
                <div class="flex items-center mt-2">
                    <input type="radio" name="displayMedia" class="mr-2" id="display-media-${mediaId}" value="${mediaId}">
                    <label for="display-media-${mediaId}" class="text-xs text-gray-600">カードに表示</label>
                </div>
            `;
            mediaItemDiv.insertBefore(inputElement, mediaItemDiv.querySelector('.media-action-buttons')); // input要素を正しい位置に挿入
            mediaInputsContainer.appendChild(mediaItemDiv);

            // イベントリスナーの追加
            mediaItemDiv.querySelector('.remove-media-button').addEventListener('click', () => {
                mediaItemDiv.remove();
                if (selectedMediaForCardDisplayId === mediaId) {
                    selectedMediaForCardDisplayId = null;
                }
            });

            mediaItemDiv.querySelector('.move-up-media-button').addEventListener('click', () => {
                moveMediaItem(mediaItemDiv, 'up');
            });
            mediaItemDiv.querySelector('.move-down-media-button').addEventListener('click', () => {
                moveMediaItem(mediaItemDiv, 'down');
            });

            mediaItemDiv.querySelector(`input[name="displayMedia"]`).addEventListener('change', (event) => {
                selectedMediaForCardDisplayId = event.target.value;
            });
        };

        /**
         * メディア項目を移動する関数
         * @param {HTMLElement} mediaItemDiv - 移動するメディア項目のDOM要素
         * @param {string} direction - 'up' または 'down'
         */
        const moveMediaItem = (mediaItemDiv, direction) => {
            const parent = mediaItemDiv.parentNode;
            const items = Array.from(parent.children);
            const currentIndex = items.indexOf(mediaItemDiv);

            if (direction === 'up' && currentIndex > 0) {
                parent.insertBefore(mediaItemDiv, items[currentIndex - 1]);
            } else if (direction === 'down' && currentIndex < items.length - 1) {
                parent.insertBefore(items[currentIndex + 1], mediaItemDiv);
            }
            // 並び替え後もラジオボタンのチェック状態を維持
            if (selectedMediaForCardDisplayId) {
                const radioToSelect = document.getElementById(`display-media-${selectedMediaForCardDisplayId}`);
                if (radioToSelect) {
                    radioToSelect.checked = true;
                }
            }
        };


        /**
         * ノートの内容をカードにレンダリングするヘルパー関数
         * @param {HTMLElement} containerElement - 内容をレンダリングするDOM要素 (例: .note-body)
         * @param {Array<Object>} contentParts - ノートのコンテンツ部分の配列
         * @param {string|null} [displayMediaId=null] - カード表示時に表示する単一メディアのID。nullの場合は全表示。
         */
        const renderNoteContent = (containerElement, contentParts, displayMediaId = null) => {
            containerElement.innerHTML = ''; // 既存の内容をクリア
            contentParts.forEach(part => {
                // テキストパートは常に表示
                if (part.type === 'text') {
                    const p = document.createElement('p');
                    p.classList.add('text-sm', 'text-gray-600', 'mb-1');
                    p.textContent = part.value;
                    containerElement.appendChild(p);
                } else {
                    // カード表示の場合 (displayMediaIdが指定されている) は、選択されたメディアのみ表示
                    // 詳細表示の場合 (displayMediaIdがnull) は、すべてのメディアを表示
                    if (displayMediaId === null || (part.mediaId && part.mediaId === displayMediaId)) {
                        if (part.type === 'image') {
                            const img = document.createElement('img');
                            img.src = part.value;
                            img.classList.add('w-full', 'h-auto', 'rounded-md', 'object-cover', 'mt-1', 'mb-1');
                            img.onerror = () => { img.src = `https://placehold.co/150x100/A0AEC0/FFFFFF?text=Image+Load+Error`; img.alt = '画像読み込みエラー'; };
                            containerElement.appendChild(img);
                        } else if (part.type === 'audio') {
                            const audio = document.createElement('audio');
                            audio.controls = true;
                            audio.src = part.value;
                            audio.classList.add('w-full', 'mt-1', 'mb-1');
                            containerElement.appendChild(audio);
                        } else if (part.type === 'video') {
                            const video = document.createElement('video');
                            video.controls = true;
                            video.src = part.value;
                            video.classList.add('w-full', 'h-auto', 'rounded-md', 'object-cover', 'mt-1', 'mb-1');
                            containerElement.appendChild(video);
                        } else if (part.type === 'markdown') {
                            const markdownHtml = marked.parse(part.value);
                            const div = document.createElement('div');
                            div.classList.add('markdown-content', 'text-sm', 'text-gray-700', 'bg-gray-100', 'p-2', 'rounded-md', 'mt-1', 'mb-1', 'overflow-auto');
                            div.innerHTML = markdownHtml;
                            containerElement.appendChild(div);
                        }
                    }
                }
            });
            // MathJaxをレンダリング（コンテナ全体に対して実行）
            if (typeof MathJax !== 'undefined' && typeof MathJax.typesetPromise === 'function') {
                MathJax.typesetPromise([containerElement]).catch((err) => console.error("MathJax typesetting failed:", err));
            } else {
                console.warn("MathJax or MathJax.typesetPromise is not ready yet. Retrying typesetting after MathJax startup.");
                if (typeof MathJax !== 'undefined' && MathJax.startup && MathJax.startup.promise) {
                     MathJax.startup.promise.then(() => {
                         if (typeof MathJax.typesetPromise === 'function') {
                             MathJax.typesetPromise([containerElement]).catch((err) => console.error("MathJax typesetting failed on retry:", err));
                         }
                     });
                }
            }
        };

        /**
         * ノートカードのDOM要素を作成するヘルパー関数
         * @param {Object} noteData - ノートデータオブジェクト
         * @returns {HTMLElement} 作成されたノートカードのDOM要素
         */
        const createNoteCardDOMElement = (noteData) => {
            const noteCard = document.createElement('div');
            noteCard.classList.add('note-card', 'group', 'relative', 'bg-gray-50', 'p-4', 'rounded-lg', 'shadow-sm', 'border', 'border-gray-200', 'hover:shadow-md', 'transition-shadow', 'duration-200', 'cursor-pointer');
            noteCard.dataset.id = noteData.id;
            // contentPartsとtagsをJSON文字列としてdata属性に保存
            noteCard.dataset.contentParts = JSON.stringify(noteData.contentParts);
            noteCard.dataset.tags = JSON.stringify(noteData.tags || []); // タグを追加
            noteCard.dataset.selectedDisplayMediaId = noteData.selectedDisplayMediaId || ''; // カード表示用メディアIDも保存

            let tagsHtml = '';
            if (noteData.tags && noteData.tags.length > 0) {
                // 最大3つまで表示
                tagsHtml = noteData.tags.slice(0, 3).map(tag => `<span class="tag-chip">${tag}</span>`).join('');
                if (noteData.tags.length > 3) {
                    tagsHtml += `<span class="tag-chip">...</span>`;
                }
            }


            noteCard.innerHTML = `
                <h3 class="font-semibold text-gray-800 mb-2 note-title">${noteData.title}</h3>
                <div class="note-body text-sm text-gray-600 mb-2"></div> <!-- コンテンツ表示用の新しいコンテナ -->
                <div class="flex flex-wrap items-center mt-2 mb-2">
                    ${tagsHtml}
                </div>
                <div class="text-xs text-gray-400 mt-2 note-date">${noteData.date}</div>
                <div class="note-actions absolute top-2 right-2 flex space-x-2 opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                    <button class="edit-note-button bg-blue-100 text-blue-600 hover:bg-blue-200 p-1 rounded-full flex items-center justify-center transition-colors duration-200">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pencil w-4 h-4"><path d="M17 3a2.85 2.85 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/></svg>
                    </button>
                    <button class="delete-note-button bg-red-100 text-red-600 hover:bg-red-200 p-1 rounded-full flex items-center justify-center transition-colors duration-200">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-trash-2 w-4 h-4"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg>
                    </button>
                </div>
            `;
            const noteBody = noteCard.querySelector('.note-body');
            // renderNoteContentは、コンテンツを挿入し、その要素に対してMathJaxをタイプセットする
            renderNoteContent(noteBody, noteData.contentParts, noteData.selectedDisplayMediaId);
            return noteCard;
        };

        // タグチップを生成して表示領域に追加する関数
        const addTagChip = (tag) => {
            if (currentTags.includes(tag)) return; // 重複タグは追加しない

            currentTags.push(tag);
            const chip = document.createElement('span');
            chip.classList.add('tag-chip');
            chip.textContent = tag;

            const removeButton = document.createElement('button');
            removeButton.classList.add('tag-chip-remove');
            removeButton.innerHTML = `<svg class="w-3 h-3" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 14">
                                        <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m1 1 6 6m0 0 6 6M7 7l6-6M7 7l-6 6"/>
                                      </svg>`;
            removeButton.addEventListener('click', () => {
                chip.remove();
                currentTags = currentTags.filter(t => t !== tag);
            });

            chip.appendChild(removeButton);
            tagsDisplayArea.appendChild(chip);
        };

        // タグ入力フィールドのイベントリスナー
        tagInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' || event.key === ',') {
                event.preventDefault(); // Enterキーやカンマでフォームが送信されるのを防ぐ
                const tag = tagInput.value.trim();
                if (tag && tag !== ',') { // 空文字やカンマだけのタグは追加しない
                    addTagChip(tag.replace(/,/g, '')); // カンマを削除して追加
                    tagInput.value = '';
                }
            }
        });

        tagInput.addEventListener('input', (event) => {
            // カンマが入力されたらタグを追加
            if (event.data === ',') {
                const tag = tagInput.value.slice(0, -1).trim(); // 最後のカンマを除去
                if (tag) {
                    addTagChip(tag);
                    tagInput.value = '';
                }
            }
        });


        // ノートの保存または更新
        saveNoteButton.addEventListener('click', () => {
            const title = noteTitleInput.value.trim();
            const mainContentText = noteContentInput.value.trim(); // メインのテキストエリアの内容

            // タグ入力フィールドに残っているテキストがあればタグとして追加
            const remainingTag = tagInput.value.trim();
            if (remainingTag) {
                addTagChip(remainingTag);
                tagInput.value = ''; // クリア
            }

            // コンテンツ部分の配列を作成
            const contentParts = [];
            if (mainContentText !== '') {
                contentParts.push({ type: 'text', value: mainContentText });
            }

            // モーダル内の現在のメディア入力要素からデータを収集
            let hasMediaContent = false;
            const mediaInputElements = mediaInputsContainer.querySelectorAll('.media-input-item');
            mediaInputElements.forEach(mediaItemDiv => {
                const type = mediaItemDiv.dataset.type;
                const valueInput = mediaItemDiv.querySelector('input[type="url"], textarea');
                const value = valueInput ? valueInput.value.trim() : '';
                const mediaId = mediaItemDiv.dataset.mediaId;
                if (value !== '') {
                    contentParts.push({ type: type, value: value, mediaId: mediaId });
                    hasMediaContent = true;
                }
            });

            // --- バリデーションルール ---
            if (title === '') {
                displayMessage('タイトルは必須です！', 'error');
                return;
            }

            // メディアが全くなく、本文もタグもない場合
            if (!hasMediaContent && mainContentText === '' && currentTags.length === 0) {
                displayMessage('本文、メディア、またはタグのいずれかを入力してください！', 'error');
                return;
            }
            // --- バリデーションここまで ---

            const now = new Date();
            const dateString = `${now.getFullYear()}/${(now.getMonth() + 1).toString().padStart(2, '0')}/${now.getDate().toString().padStart(2, '0')} ${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;

            let finalSelectedDisplayMediaId = null;
            const selectedRadio = document.querySelector('input[name="displayMedia"]:checked');
            if (selectedRadio) {
                finalSelectedDisplayMediaId = selectedRadio.value;
            } else if (hasMediaContent) {
                const firstMediaPart = contentParts.find(part => part.type !== 'text' && part.mediaId && part.value !== '');
                if (firstMediaPart) {
                    finalSelectedDisplayMediaId = firstMediaPart.mediaId;
                }
            }

            const noteData = {
                id: isEditing ? editingNoteCard.dataset.id : Date.now().toString(),
                title: title,
                date: dateString,
                contentParts: contentParts, // 構造化されたコンテンツ配列
                tags: [...currentTags], // 現在のタグ配列をコピーして保存
                selectedDisplayMediaId: finalSelectedDisplayMediaId // カード表示用メディアID
            };

            if (isEditing) {
                // 既存のノートを更新
                editingNoteCard.querySelector('.note-title').textContent = noteData.title;
                const noteBody = editingNoteCard.querySelector('.note-body');
                renderNoteContent(noteBody, noteData.contentParts, noteData.selectedDisplayMediaId); // コンテンツを再レンダリング

                // タグの表示を更新
                const existingTagsDisplay = editingNoteCard.querySelector('.flex.flex-wrap.items-center');
                if (existingTagsDisplay) {
                    existingTagsDisplay.innerHTML = ''; // クリア
                    if (noteData.tags && noteData.tags.length > 0) {
                        noteData.tags.slice(0, 3).forEach(tag => {
                            const tagChip = document.createElement('span');
                            tagChip.classList.add('tag-chip');
                            tagChip.textContent = tag;
                            existingTagsDisplay.appendChild(tagChip);
                        });
                        if (noteData.tags.length > 3) {
                            const ellipsisChip = document.createElement('span');
                            ellipsisChip.classList.add('tag-chip');
                            ellipsisChip.textContent = '...';
                            existingTagsDisplay.appendChild(ellipsisChip);
                        }
                    }
                }

                editingNoteCard.querySelector('.note-date').textContent = noteData.date;
                editingNoteCard.dataset.contentParts = JSON.stringify(noteData.contentParts); // data属性も更新
                editingNoteCard.dataset.tags = JSON.stringify(noteData.tags); // タグのdata属性を更新
                editingNoteCard.dataset.selectedDisplayMediaId = noteData.selectedDisplayMediaId || ''; // data属性も更新
            } else {
                // 新しいノートを作成
                const newNoteCard = createNoteCardDOMElement(noteData);
                notesGrid.prepend(newNoteCard); // 最新のノートを一番上に追加
            }
            closeNoteModal();
            applySearchFilter(); // 保存後にフィルターを再適用
            displayMessage('メモを保存しました！', 'success');
        });

        // ノート追加ボタンのイベントリスナー
        addNoteButton.addEventListener('click', () => {
            // 新規メモ追加時にメディアの選択状態とメディア入力をリセット
            selectedMediaForCardDisplayId = null;
            mediaInputsContainer.innerHTML = ''; // これが重要
            noteContentInput.value = ''; // メインのテキストエリアもクリア
            currentTags = []; // タグもリセット
            tagsDisplayArea.innerHTML = ''; // タグ表示エリアもクリア
            tagInput.value = ''; // タグ入力フィールドもクリア
            openNoteModal("メモを追加");
        });

        // モーダルのキャンセルボタン
        cancelNoteButton.addEventListener('click', closeNoteModal);

        // 削除確認モーダルのキャンセルボタン
        cancelDeleteButton.addEventListener('click', closeDeleteConfirmModal);

        // 削除確認モーダルの削除ボタン
        confirmDeleteButton.addEventListener('click', () => {
            if (editingNoteCard) {
                editingNoteCard.remove();
                displayMessage('メモを削除しました！', 'success');
            }
            closeDeleteConfirmModal();
        });

        // メモ詳細モーダルの閉じるボタンのイベントリスナー
        closeDetailModalButton.addEventListener('click', closeNoteDetailModal);
        closeDetailModalButtonFooter.addEventListener('click', closeNoteDetailModal);


        // ノートカード内の編集/削除ボタンのイベント委譲
        notesGrid.addEventListener('click', (event) => {
            const target = event.target;
            const noteCard = target.closest('.note-card');

            if (!noteCard) return;

            // 編集ボタンがクリックされた場合
            if (target.closest('.edit-note-button')) {
                isEditing = true;
                editingNoteCard = noteCard;

                const title = noteCard.querySelector('.note-title').textContent;
                const contentPartsJSON = noteCard.dataset.contentParts;
                const tagsJSON = noteCard.dataset.tags || '[]'; // タグデータがない場合のフォールバック
                const noteSelectedDisplayMediaId = noteCard.dataset.selectedDisplayMediaId || null;
                selectedMediaForCardDisplayId = noteSelectedDisplayMediaId; // グローバル変数に既存の選択を設定

                let contentParts = [];
                if (contentPartsJSON) {
                    try {
                        contentParts = JSON.parse(contentPartsJSON);
                    } catch (e) {
                        console.error("Failed to parse contentParts for editing:", e);
                        contentParts = [{ type: 'text', value: noteCard.querySelector('.note-body')?.textContent || '' }];
                    }
                } else {
                    contentParts = [{ type: 'text', value: noteCard.querySelector('.note-body')?.textContent || '' }];
                }

                let tags = [];
                try {
                    tags = JSON.parse(tagsJSON);
                } catch (e) {
                    console.error("Failed to parse tags for editing:", e);
                    tags = [];
                }

                // 編集時もメディア入力コンテナをクリアしてから再構築
                mediaInputsContainer.innerHTML = '';

                let mainText = '';
                contentParts.forEach(part => {
                    if (part.type === 'text') {
                        // メインテキストエリアが複数のテキストパートを含む可能性を考慮し、結合
                        mainText += part.value + '\n\n';
                    } else {
                        // mediaIdを渡し、既存のメディアとして追加
                        addMediaInput(part.type, part.value, part.mediaId);
                    }
                });
                noteContentInput.value = mainText.trim(); // メインテキストエリアに設定

                // タグを読み込んで表示
                currentTags = []; // リセット
                tagsDisplayArea.innerHTML = ''; // クリア
                tagInput.value = ''; // クリア
                tags.forEach(tag => addTagChip(tag));


                openNoteModal("メモを編集", title); // ここではクリアしない

                // 編集モードでモーダルを開いた後、選択されたラジオボタンをチェック
                if (selectedMediaForCardDisplayId) {
                    const radioToSelect = document.getElementById(`display-media-${selectedMediaForCardDisplayId}`);
                    if (radioToSelect) {
                        radioToSelect.checked = true;
                    }
                }
            }
            // 削除ボタンがクリックされた場合
            else if (target.closest('.delete-note-button')) {
                editingNoteCard = noteCard;
                openDeleteConfirmModal();
            }
            // メモカード自体がクリックされた場合（詳細表示）
            else {
                const title = noteCard.querySelector('.note-title').textContent;
                const contentPartsJSON = noteCard.dataset.contentParts;
                const tagsJSON = noteCard.dataset.tags || '[]'; // タグデータがない場合のフォールバック

                let contentParts = [];
                if (contentPartsJSON) {
                    try {
                        contentParts = JSON.parse(contentPartsJSON);
                    } catch (e) {
                        console.error("Failed to parse contentParts for detail display:", e);
                        contentParts = [{ type: 'text', value: noteCard.querySelector('.note-body')?.textContent || '' }];
                    }
                } else {
                     contentParts = [{ type: 'text', value: noteCard.querySelector('.note-body')?.textContent || '' }];
                }

                let tags = [];
                try {
                    tags = JSON.parse(tagsJSON);
                } catch (e) {
                    console.error("Failed to parse tags for detail display:", e);
                    tags = [];
                }

                openNoteDetailModal({ title: title, contentParts: contentParts, tags: tags });
            }
        });

        // 検索とフィルターを適用する関数
        const applySearchFilter = () => {
            const searchTerm = searchNotesInput.value.toLowerCase();
            const allNoteCards = notesGrid.querySelectorAll('.note-card');

            allNoteCards.forEach(card => {
                const title = card.querySelector('.note-title').textContent.toLowerCase();
                let shouldDisplay = false;

                const contentPartsJSON = card.dataset.contentParts;
                let contentParts = [];
                if (contentPartsJSON) {
                    try {
                        contentParts = JSON.parse(contentPartsJSON);
                    } catch (e) {
                        console.error("Failed to parse contentParts for search:", e);
                        // パース失敗時のフォールバック (念のため)
                        contentParts = [{ type: 'text', value: card.querySelector('.note-body')?.textContent || '' }];
                    }
                } else {
                     // data-content-partsがない場合のフォールバック (古いノート対応)
                     contentParts = [{ type: 'text', value: card.querySelector('.note-body')?.textContent || '' }];
                }

                const tagsJSON = card.dataset.tags || '[]';
                let tags = [];
                try {
                    tags = JSON.parse(tagsJSON);
                } catch (e) {
                    console.error("Failed to parse tags for search:", e);
                    tags = [];
                }

                let searchableContent = '';
                contentParts.forEach(part => {
                    if (part.type === 'text' || part.type === 'markdown') {
                        searchableContent += part.value.toLowerCase() + ' ';
                    }
                });
                // タグも検索対象に含める
                tags.forEach(tag => {
                    searchableContent += tag.toLowerCase() + ' ';
                });


                if (currentFilter === 'both') {
                    shouldDisplay = title.includes(searchTerm) || searchableContent.includes(searchTerm);
                } else if (currentFilter === 'title') {
                    shouldDisplay = title.includes(searchTerm);
                } else if (currentFilter === 'content') {
                    shouldDisplay = searchableContent.includes(searchTerm);
                }

                card.style.display = shouldDisplay ? '' : 'none';
            });
        };

        // 検索機能のイベントリスナー
        searchNotesInput.addEventListener('input', applySearchFilter);

        // フィルターボタンのイベントリスナー
        filterButton.addEventListener('click', (event) => {
            event.stopPropagation();
            filterOptions.classList.toggle('hidden');
            filterOptions.classList.toggle('active');
        });

        // フィルター選択肢のイベントリスナー
        filterOptionItems.forEach(item => {
            item.addEventListener('click', (event) => {
                currentFilter = event.target.dataset.filter;
                filterOptionItems.forEach(opt => opt.classList.remove('selected'));
                event.target.classList.add('selected');
                filterOptions.classList.add('hidden');
                filterOptions.classList.remove('active');
                applySearchFilter();
            });
        });

        // ドキュメント全体をクリックしたときにフィルターオプションを非表示にする
        document.addEventListener('click', (event) => {
            // フィルターオプションを閉じる
            if (!filterOptions.contains(event.target) && !filterButton.contains(event.target)) {
                filterOptions.classList.add('hidden');
                filterOptions.classList.remove('active');
            }
        });

        // クリアボタンのイベントリスナー
        clearSearchButton.addEventListener('click', () => {
            searchNotesInput.value = '';
            applySearchFilter();
        });

        // レイアウト切り替え機能のイベントリスナー
        toggleLayoutButton.addEventListener('click', () => {
            if (isGridLayout) {
                notesGrid.classList.remove('notes-grid-layout');
                notesGrid.classList.add('notes-list-layout');
                gridIcon.classList.add('hidden');
                listIcon.classList.remove('hidden');
            } else {
                notesGrid.classList.remove('notes-list-layout');
                notesGrid.classList.add('notes-grid-layout');
                listIcon.classList.add('hidden');
                gridIcon.classList.remove('hidden');
            }
            isGridLayout = !isGridLayout;
        });

        // メディア追加ボタン群のイベントリスナー
        addMediaImageButton.addEventListener('click', () => addMediaInput('image'));
        addMediaAudioButton.addEventListener('click', () => addMediaInput('audio'));
        addMediaVideoButton.addEventListener('click', () => addMediaInput('video'));
        addMediaMarkdownButton.addEventListener('click', () => addMediaInput('markdown'));


        // 初期サンプルノートデータ
        const sampleNotesData = [
            {
                id: '1',
                title: '今日のタスク',
                date: '2025/05/23 10:30',
                contentParts: [
                    { type: 'text', value: '買い物リストを作成する。牛乳、卵、パン、野菜、果物。\n会議の資料を準備する。プレゼンテーションの最終確認。\nジムに行く。30分ランニングと筋トレ。' }
                ],
                tags: ['タスク', '買い物', '仕事', '健康'],
                selectedDisplayMediaId: null
            },
            {
                id: '2',
                title: 'アイデアメモ',
                date: '2025/05/22 15:00',
                contentParts: [
                    { type: 'text', value: '新しいプロジェクトの企画。ターゲット層の分析と競合調査。\nユニークな機能のブレインストーミング。\nチームメンバーとの役割分担。' },
                    { type: 'image', value: 'https://placehold.co/300x200/FF5733/FFFFFF?text=Idea', mediaId: 'media-idea-1' }
                ],
                tags: ['プロジェクト', '企画', 'アイデア', 'ブレインストーミング'],
                selectedDisplayMediaId: 'media-idea-1'
            },
            {
                id: '3',
                title: '読書リスト',
                date: '2025/05/21 09:45',
                contentParts: [
                    { type: 'text', value: '「デザイン思考」に関する書籍を読む。\n「Pythonプログラミング入門」を復習する。\n「歴史小説」を読み始める。' }
                ],
                tags: ['読書', '学習', '自己啓発', 'プログラミング'],
                selectedDisplayMediaId: null
            },
            {
                id: '4',
                title: '旅行計画',
                date: '2025/05/20 18:15',
                contentParts: [
                    { type: 'markdown', value: `## 計画概要
* **目的地**: 北海道 or 沖縄
* **期間**: 1週間
* **アクティビティ**:
    * 絶景スポット巡り
    * ご当地グルメ
    * 温泉

### 準備事項
1.  航空券と宿泊施設の予約
2.  観光スポットの調査
3.  持ち物リスト作成

数式例:
インライン数式は $E=mc^2$ のように書けます。
ディスプレイ数式は
$$ \\sum_{n=1}^\infty \\frac{1}{n^2} = \\frac{\\pi^2}{6} $$
のように書けます。
`, mediaId: 'media-travel-markdown-1' }
                ],
                tags: ['旅行', '計画', '北海道', '沖縄', 'アクティビティ'],
                selectedDisplayMediaId: 'media-travel-markdown-1'
            },
            {
                id: '5',
                title: 'レシピメモ',
                date: '2025/05/19 12:00',
                contentParts: [
                    { type: 'text', value: '新しいカレーのレシピを試す。\n材料: 鶏肉、玉ねぎ、じゃがいも、にんじん、カレールー。\n調理手順: 炒める、煮込む。' },
                    { type: 'audio', value: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3', mediaId: 'media-recipe-audio-1' }
                ],
                tags: ['料理', 'レシピ', 'カレー'],
                selectedDisplayMediaId: 'media-recipe-audio-1'
            },
            {
                id: '6',
                title: '朝のルーティン',
                date: '2025/05/24 07:00',
                contentParts: [
                    { type: 'text', value: '6:00 起床、ストレッチ\n6:30 朝食準備\n7:00 ニュースチェック' },
                    { type: 'video', value: 'https://www.w3schools.com/html/mov_bbb.mp4', mediaId: 'media-morning-video-1' }
                ],
                tags: ['ルーティン', '健康', '朝活'],
                selectedDisplayMediaId: 'media-morning-video-1'
            },
            {
                id: '7',
                title: '複数メディアのテスト',
                date: '2025/06/21 14:00',
                contentParts: [
                    { type: 'text', value: 'これは複数のメディアを含むテストメモです。画像と音声があります。' },
                    { type: 'image', value: 'https://placehold.co/200x150/0000FF/FFFFFF?text=Blue+Image', mediaId: 'media-multi-img-1' },
                    { type: 'audio', value: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3', mediaId: 'media-multi-audio-1' },
                    { type: 'markdown', value: '```javascript\nconsole.log("Hello Multi-Media!");\n```', mediaId: 'media-multi-md-1' }
                ],
                tags: ['テスト', 'メディア', '画像', '音声', 'マークダウン'],
                selectedDisplayMediaId: 'media-multi-img-1' // デフォルトで画像を表示
            }
        ];

        // 初期ロード時にサンプルノートをレンダリング
        // MathJaxの起動が完了するのを待ってからノートをレンダリングする
        if (typeof MathJax !== 'undefined' && MathJax.startup && MathJax.startup.promise) {
            MathJax.startup.promise.then(() => {
                sampleNotesData.forEach(noteData => {
                    const newNoteCard = createNoteCardDOMElement(noteData);
                    notesGrid.appendChild(newNoteCard);
                });
                // 初期ロード時にフィルターとレイアウトを適用
                applySearchFilter();
            }).catch(err => console.error("MathJax startup promise failed:", err));
        } else {
            console.warn("MathJax is not available or its startup promise is not defined. Rendering notes without MathJax typesetting.");
            sampleNotesData.forEach(noteData => {
                const newNoteCard = createNoteCardDOMElement(noteData);
                notesGrid.appendChild(newNoteCard);
            });
            applySearchFilter();
        }
    </script>
</body>
</html>
